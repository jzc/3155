% Document formating
\documentclass[12pt]{article}
\setlength{\parindent}{0pt}
\setlength{\oddsidemargin}{0in}
\setlength{\evensidemargin}{0in}
\setlength{\textwidth}{6.5in}
\setlength{\parindent}{0in}
\setlength{\parskip}{\baselineskip}
\usepackage{amsmath,amsfonts,amssymb,wasysym}
\setlength{\evensidemargin}{1in}
\addtolength{\evensidemargin}{-1in}
\setlength{\oddsidemargin}{1.5in}
\addtolength{\oddsidemargin}{-1.5in}
\setlength{\topmargin}{1in}
\addtolength{\topmargin}{-1.5in}
\setlength{\textwidth}{16cm}
\setlength{\textheight}{23cm}
\setlength{\parskip}{0.75cm}

% Brackets
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}

% Typesetting options
\usepackage{fancyvrb}
\usepackage{tgbonum}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage [english]{babel}
\usepackage [autostyle, english = american]{csquotes}
\MakeOuterQuote{"}
\usepackage{upquote}
\usepackage{scrextend}
\addtokomafont{labelinglabel}{\sffamily}
\usepackage[none]{hyphenat}
\usepackage{url}
\newcommand\tab[1][1cm]{\hspace*{#1}} %creates tab command (~5 spaces)

% Tikz settings
\usepackage{tikz}
\usetikzlibrary{trees}
\usetikzlibrary {positioning}
\definecolor {mypurple}{cmyk}{0.6,0.4,0.1,0}
\definecolor {myred}{cmyk}{0,0.3,0.3,0}
\usetikzlibrary{fit,shapes.misc}
\usetikzlibrary{arrows}

% For the trees
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
    fill=white, text width=1.5em}
}

% Fancy font
\usepackage{amsmath}
\usepackage{mathrsfs}
\DeclareMathAlphabet{\mathscrbf}{OMS}{mdugm}{b}{n}

% Other math tools
\usepackage{mathtools}

% Other useful options
\usepackage[table]{colortbl}

% Other graphics
\graphicspath{{images/}}

% Links
\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
}
 
\urlstyle{same}

% --------------------------------
\begin{document}

% ------------- HEADER -----------
CSCI 3155, Spring 2018 \hfill Lab 2 Writeup  (02/09/2018)\\
Blaise Page  \hfill blpa1200@colorado.edu\\
Justin Cai \hfill juca7186@colorado.edu\vspace{-13mm}\\

\hrulefill

{\fontfamily{cmr}\selectfont\vspace{-8mm}
% ##################  PROBLEM 2 #####################
\section*{{\fontfamily{qcr}\selectfont Problem 2}}\vspace{-10mm}
\begin{enumerate}

% ##################  2.a #####################
\item[(a)] 
\tab The sentence generated by this language would start with one or more 'a's, followed by some number of 'b's and 'c's. It is important to note that every 'b' will have a corresponding 'c' because everytime the bBc case is invoked, it results in a 'b' and 'c' pair. Moreover, the sentence will also end with one or more 'a's.

% ##################  2.b #####################
\item[(b)] 
The following sentences are generated by the grammar:
\begin{enumerate}
\item[1.] baab
\begin{verbatim}
S => AaBb
  => baBb
  => baab
\end{verbatim}
\item[4.] bbaab
\begin{verbatim}
S => AaBb
  => AbaBb
  => bbaBb
  => bbaab
\end{verbatim}
\end{enumerate}

% ##################  2.c #####################
\item[(c)]
The following sentences are generated by the grammar:
\begin{enumerate}
\item[1.] abcd\\
\usetikzlibrary{arrows}
\tikzset{
  treenode/.style = {align=center, inner sep=0pt, text centered,
    font=\sffamily},
  arn_n/.style = {treenode, circle, black, font=\sffamily\bfseries, draw=black,
    fill=white, text width=1.5em}
}
\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 3cm/#1, level distance = 1.5cm}] 
\node [arn_n] {S}
    child{ node [arn_n] {a}}
    child{ node [arn_n] {S}
            child{ node [arn_n] {b}}
   }
   child{ node [arn_n] {c}} 
   child{ node [arn_n] {B}
            child{ node [arn_n] {d}}
   }                       
; 
\end{tikzpicture}
\newpage
\item[5.] accc\\
\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 3cm/#1, level distance = 1.5cm}] 
\node [arn_n] {S}
    child{ node [arn_n] {a}}
    child{ node [arn_n] {S}
            child{ node [arn_n] {A}
		  child{ node [arn_n] {c}}
            }
   }
   child{ node [arn_n] {c}} 
   child{ node [arn_n] {B}
            child{ node [arn_n] {A}
                    child{ node [arn_n] {c}}
            }
   }                         
; 
\end{tikzpicture}
\end{enumerate}

% ##################  2.d #####################
\item[(d)] The following trees show that the grammar is ambiguous, because they are different trees, yet they generate the same sentence:\\

\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2cm/#1, level distance = 1.5cm}] 
\node [arn_n] {S}
    child{ node [arn_n] {A}
            child{ node [arn_n] {a}}
    }
   child{ node [arn_n] {$\oplus$}} 
   child{ node [arn_n] {A}
                  child{ node [arn_n] {a}}
	         child{ node [arn_n] {$\oplus$}}
		 child{ node [arn_n] {a}}
   }
;
\end{tikzpicture}
\hfill
\begin{tikzpicture}[->,>=stealth',level/.style={sibling distance = 2cm/#1, level distance = 1.5cm}] 
\node [arn_n] {S}
   child{ node [arn_n] {A}
                  child{ node [arn_n] {a}}
	         child{ node [arn_n] {$\oplus$}}
		 child{ node [arn_n] {a}}
    }
   child{ node [arn_n] {$\oplus$}} 
   child{ node [arn_n] {A}
            child{ node [arn_n] {a}}
    }
;
\end{tikzpicture}

% ##################  2.d #####################
\item[(d)] The inference rules that inductively define the judgement form are as follows:\\
\begin{center}
${\displaystyle \frac{ x \Downarrow n  \quad  y \Downarrow m}{x \oplus y \: \Downarrow \: n+m}}$\tab ${\displaystyle \frac{}{a \: \Downarrow \: 1}}$\tab ${\displaystyle\frac{}{b \: \Downarrow \: 0}}$
\end{center}
\end{enumerate}

{\fontfamily{cmr}\selectfont\vspace{-8mm}
% ##################  PROBLEM 3 #####################
\section*{{\fontfamily{qcr}\selectfont Problem 3}}\vspace{-10mm}
\begin{enumerate}

% ##################  3.a #####################
\item[(a)]
\begin{enumerate}
\item[(i)] The expressions generated by the grammars consist of a combination of operands and operators, where the operands are seperated by operators.

\item[(ii)] Yes, the grammars generate the same expressions, but they do so with different parse trees.

\end{enumerate}

% ##################  3.b #####################
\item[(b)] Our Scala expression for testing '-' or '$<<$' precedence  is as follows:
\begin{verbatim}
if( 1 <<  3 - 2 ) == ( (1 << 3) - 2  )
  print "left shift has higher precedence"
else if ( 1 << 3 - 2 ) == ( 1 << (3 - 2) )
  print "minus has higher precedence"
\end{verbatim}

\tab The order in which the values are evaluated determines the precedence of the operators. Since scala evaluates its parse trees in a bottom-up fashion, the return from our expression shows the relative precedence of '-' and '$<<$'.

% ##################  3.c #####################
\item[(c)] The BNF grammar for floating points made up of fractions is as follows:

\begin{align*}
    % exponent must be non zero
    % fraction must be non zero for exponent
    floating\,point &::= (non\,zero\,integer) \text{`.'} (fraction) \\
    % yes 3.0, no 3.0e3 (fraction == 0), no  3.0e
    fraction &::= (middle\,sequence) | (fraction\,with\,exponent))\\
    fraction\,with\,exponent &::= (non\,zero\,fraction) \text{`E'} (non\,zero\,integer)\\
    % unlike non zero int, can have leading zeros, like 1.00001
    non\,zero\,fraction &::= (middle\,sequence)(non\,zero\,digit)\\
    % has no leading zeros, no 0001
    non\,zero\,integer &::=  \text{`-'} (non\,zero\,number) | non\,zero\,number\\
    non\,zero\,number &::= (non\,zero\,digit)(middle\,sequence)\\
    % middle sequence is any string of numbers, and can be empty.
    % goes in the "middle" of a number"
    middle\,sequence &::= (any\,digit)(middle\,sequence) | \epsilon\\
    any\,digit &::= \text{`0'} | non\,zero\,digit\\
    non\,zero\,digit &::= \text{`1'} | \text{`2'} | \text{`3'} | \text{`4'} |
                          \text{`5'} | \text{`6'} | \text{`7'} | \text{`8'} | \text{`9'}\\
\end{align*}
\end{enumerate}
\end{document}